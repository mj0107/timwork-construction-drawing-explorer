## 데이터 분석

`metadata.json`은 도면 -> 공종 -> 영역 -> 리비전으로 이어지는 깊은 중첩 구조(Deeply Nested Structure)를 가지고 있었습니다.  
이 구조는 문서 형태로 사람이 눈으로 읽기에는 직관적일 수 있으나, 상태로 관리하며 특정 리비전을 찾기 위해 트리를 매번 순회해야 하는 비효율성이 존재합니다.

이에 대한 **더 나은 데이터 표현 방법**으로, 데이터를 관계형 데이터베이스(RDBMS)의 테이블처럼 정규화하여 다루는 방법을 생각해보았습니다.  
예를 들어 "도면 목록 테이블"과 "리비전 목록 테이블"로 분리하면, 화면을 그릴 때 필요한 데이터만 한 번의 `filter` 연산으로 찾아낼 수 있어 UI 렌더링 성능과 컴포넌트 복잡도를 낮출 수 있을것 같다고 생각했습니다.

또한, 구현하다보니 key값이 없어서 id를 name등의 다른 값을 활용하여 사용했는데, 이로인해 같은 key값이 존재하게 될 경우 렌더링이 꼬일 수 있으므로 이러한 문제도 막아줄 수 있을거라고 생각했습니다.

아래는 예시입니다.

```ts
const drawing = {
  '01-구조-A-REV1': {
    id: uuid(),
    revision: 'REV1',
    name: '01-구조-A-REV1',
    imageFile: '01-구조-A-REV1.jpeg',
    imageTransform: {
      scale: 1,
      rotation: 0,
      translate: {
        x: 0,
        y: 0,
      },
    },
    // ...parent, polygon등 다른 속성들
  },
};
```

## 접근 방식

1. 데이터 환경 구성: `metadata.json`을 단순히 정적 자산으로 번들링하기보다, 실제 백엔드 API 연동과 유사한 환경을 구성하기 위해 `public/` 디렉토리에 유지하고 비동기 `fetch` 방식으로 데이터를 로드하도록 구성했습니다.
2. 데이터 해석: `metadata.json`의 구조를 먼저 파악해야 레이아웃과 컴포넌트 구조를 잡을 수 있다고 생각했습니다.
3. 타입 정의: `metadata.json`의 모든 속성을 타입으로 정의했습니다.
4. 전역 상태 정의: `metadata.json`의 데이터를 전역 상태로 관리하기 위해 **Zustand**를 사용했습니다.
5. 컴포넌트 구현: 상단 레이아웃(Header)부터 시작하여 좌측 탐색 영역(Sidebar), 리비전패널(RevisionPanel), 뷰어(Viewer) 순으로 구현했습니다.

## UI 설계 결정

- **레이아웃 (사이드바 패턴):** 현장 소장이 복잡한 데이터를 수직적인 계층(건물 -> 공종 -> 도면)으로 파악해야 하므로 좌측에 탐색용 사이드바를, 우측에 뷰어를 배치하는 레이아웃을 선택했습니다.

## 기술 선택

- **Zustand:** 트리 깊이가 깊은 JSON 데이터를 모든 컴포넌트에서 매번 `fetch`하지 않도록 앱 로드 시 한 번만 불러오게끔 전역 상태 관리를 도입했습니다. 이 때 무거운 Redux나 React Context보다 보일러플레이트가 훨씬 적고 직관적인 Zustand를 선택했습니다.
- **상태 정규화 (Single Source of Truth 확보):**
  가장 크게 신경 쓴 부분입니다. 사용자가 사이드바에서 특정 도면을 클릭했을 때, 스토어에 도면 데이터 전체를 통째로 복사해 저장(`selectedDrawing: Drawing`)하지 않고, **식별자인 ID(`selectedDrawingId`) 값만 저장**하도록 설계했습니다. 이를 통해 원본 데이터가 변경될 때 선택된 데이터는 갱신되지 않는 문제를 방지하였습니다. 데이터가 필요할 땐 컴포넌트 내에서 ID를 통해 원본 데이터를 찾아 사용했습니다.
- **스타일링 (Tailwind CSS, clsx, tailwind-merge):** 빠르고 일관된 디자인 시스템 적용을 위해 도입했습니다. 특히, 선택된 탭 강조 등 동적으로 스타일이 변경될 때 발생할 수 있는 캐스케이딩 충돌 문제를 해결하기 위해 유틸리티 함수(cn)를 구성해 적용했습니다.
- **canvas 대신 svg**: 비록 숙련도가 부족해 polyline이나 오버레이 기능을 구현하지 못했지만, 뷰어의 확대/축소/이동 기능을 구현하기에는 svg가 더 적합하다고 판단했습니다. svg를 활용시에는 확대해도 이미지가 깨지지 않기 때문입니다.

## 어려웠던 점 및 개선 방안

- **Zustand 선택자와 리렌더링 감지 이슈:**
  상태 관리 로직 구현 중, 스토어 내부에서 `Array.map()`을 이용해 가공된 배열을 곧바로 반환하는 셀렉터를 작성했습니다. 그러나 이는 Zustand의 엄격한 비교에서 매번 새로운 참조 배열로 인식되어, `Maximum update depth exceeded` (무한 렌더링 루프) 에러를 발생시켰습니다.
  이를 파악한 후, 스토어는 원본 데이터만 반환하게 하고 데이터의 `map` 가공 로직은 데이터를 사용하는 컴포넌트 안으로 분리함으로써 문제를 해결했습니다.
- **개선 방안:**
  시간적 제약으로 캔버스 구현을 완벽하게 끝마치지는 못했습니다. 시간이 더 주어진다면, 메타데이터에 포함된 두 종류의 트랜스폼 데이터(`imageTransform`, `polygonTransform`)를 이용하여 오버레이 및 폴리곤으로 렌더링하는 기능을 고도화하고 싶습니다.
